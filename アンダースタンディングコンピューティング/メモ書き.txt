■プログラムの意味
プログラマはいろいろな言語を学ぶがプログラムの意味を考えることがほぼない。
→突如現れた呪文的なものに思えてくる。
  →プログラムはその時点のアイデアをスナップショットしたもの。

プログラム言語を記述するためには以下の2つが必要
・構文
・意味論→プログラムが何を意味するか

プログラミング言語を記述する方法
・実装による仕様を用意する
・公式文書として仕様書を書く
・形式意味論の数学的テクニックを利用してプログラミング言語の意味を正確に記述すること。
  ※形式意味論＝とらえどころのないプログラムの意味を証明したり発見したりする学問。
  
コンピュータプログラムは必ず有効なプログラムかを判断する規則の集まりがある。
その規則を構文と呼ぶ。
プログラムを読むためにはパーサを利用し文字列を読み、規則にあっているかを確認して
処理に適した構造化された表現へと変換するプログラムのこと
  # コンパイラでは？

プログラムの意味を考えるとき、最も実践的な方法はプログラムが何をするのかを考えること。= 操作的意味論
操作的意味論は記述内容が装置の上でどのように動くかを考えるものであり、
その装置は抽象機械となる。その抽象機械は言語ごとに違うことが普通。

どのように抽象機械を設計し操作的意味論を記述するか
・構文を小さなステップで繰り返し簡約する。＝数学の展開とか因数分解とかを途中式を書いていくような感じ。

式の目的＝評価されることで別の式を生成すること
文の目的＝評価されることで抽象機械の状態を変更すること

最も文で簡単なものは何もしないもの。
何もしないものの用途としてはプログラムの実行が正しく終了したことを示すための特別な分として利用。

代入の簡約規則は以下のとおり
・代入文の式が簡約可能な場合その式を簡約する。その結果、簡約された代入文と変更のない環境が得られる。
・代入文の式が簡約不可能な場合、その式を代入文の変数と関連付けて環境を更新する。その結果<<do-nothing>>文と
  新しい環境が得られる。

・条件が簡約可能である場合、条件を簡約する。簡約された条件文ともとのままの環境が得られる
・条件が式<<true>>の場合、帰結文ともとのままの環境に簡約する。
・条件が式<<false>>の場合、代替文と元のままの環境に簡約する。

誤った値まで常に簡約しようとするとエラーがでるので、制限を設けることが必要。

スモールステップ操作意味論とは
実行状態を管理する抽象機械を設計しプログラム構成要素をインク裏面たるに評価する方法について
記述した簡約規則を定義しプログラムが完全に評価されるまで簡約すること。
スモールステップ意味論には反復という特徴があり簡約規則を繰り返し実行するための
抽象機械が必要となる。

それを直接的に分かるようにしたものがビッグステップ意味論。
ビッグステップ意味論ではどうやって式や文から直接結果を得るかということを記述する。
ビッグステップ意味論では反復ではなく再帰を利用する。

スモールステップ意味論の実装ではRubyのコールスタックをあまり呼んでいない。
メッセージが抽象構文木を伝わって簡約可能なコードに到達するまで呼び出された#reduceはいくらか入れ子に呼び出される。
ただし仮想機械は小さな簡約を繰り返し実行しながら現在のプログラムと環境を保持することによって
計算全体の進行を記録する。そのためコールスタックの深さはプログラムの構文木の深さに制限される。
スモールステップ意味論の入れ子は簡約そのものを実行しているわけではなく、次に簡約するものを探すための構文木の
走査に利用されているだけ。

ビッグステップ意味論はスタックを多用する。
計算全体のどこにいるのか、計算の一部として小さな計算実行、評価対象の記録などは全てスタック。

表示的意味論＝プログラムをネイティブ言語から別の表現に変換することに関心がある
操作的意味論よりも抽象的。例えばwalkをmarcherに言い換えるようなもの。
操作的意味論の場合なら歩く動作をみせる。
なので抽象構文木をその木が意図した意味を表現するRubyコードの文字列に変換することになる。

操作的意味論の場合、環境は仮想機械内にあるので変数を抽象構文木に関連付けていた。
表示的意味論の場合、環境はプログラムの変換先の言語内にあるのでその世界で意味をなすようにする必要がある。

表示的意味論で重要なのは合成。

各意味論の違いを理解するためにはWhileの動作の違いを見るとよい。
スモールステップは抽象機械のための簡約規則として置かれる。
ビッグステップは最終的な環境を直接計算する方法を示した評価規則としてかかれる。
表示的意味論はRubyなど言語のWhileに書き直す方法を示している。

表示的意味論の目的は独自な言語を実装言語に置き換えて動作させること。
この置き換えに意味を与えるために言語の処理を元の実装言語に任せるのではなく
独自言語側で説明を加えること。ほぼほぼコンパイラ。

本来の形式意味論は数学のツールを使うことが一般的。
形式意味論の重要な応用は実装による仕様といった非形式仕様に頼らずプログラミング言語の意味にあいまいさのない仕様をあたえること。

また今回見た意味論にはさまざまな呼び名がついている。
スモールステップ＝構造的操作的意味論、遷移意味論など
ビッグステップ＝自然意味論、関係意味論
表示的意味論＝不動点意味論、数学的意味論

コンピュータは通常、大量の揮発性メモリと不揮発性ストレージ、入出力デバイス、命令を同時実行できる複数のプロセッサコアを備えている。
有限状態機械、有限オートマトンとは理解しやすさ、推測しやすさ、HW、SWによる実装のしやすさの代わりに機能を取り除いて単純化したもの。
有限オートマトンには永続的ストレージは存在せず、RAMすらない。
あるのはいくつかのとりえる状態とどの状態にいるかを記録する能力を備えた小さな機械。
任意のプログラムは実行できず入力に応じてある状態から別の状態への移動方法を決める規則の集合がハードコードされている。
例えば状態1でaを読むと状態2に変わり、状態2でaを読むと状態1に変わるといったような内容がハードコードされている
実際この状態だと状態は1つしかないのと変わらない。

有限オートマトンには出力も備わっているが一部の状態に特別な印をつけて機械がその状態であるかどうかを1ビット出力するだけ。
この特別な状態を受理状態と呼ぶ。また機会が特定の入力シーケンスを受理、拒否するという概念を表している。
例えば状態2を受理状態として状態1でaを読むと状態2に、状態2でaを読むと状態1に移動するとした場合
状態1でaと入力すれば受理、aaと入力すれば状態1に戻ってくるので拒否となる。
状態からの移動については複数種類を持たせることも可能で、自身に移動するルールを設けることも可能。
こういったオートマトンは決定的であるということが重要。
決定的であるという確実性は以下の制約を守ることで保証される。
・矛盾がないこと
・省略がないこと
つまり状態と入力に対して規約を1つだけ持つ必要があるということ。

オートマトンは実行したタイミングでどこの状態にいるか分からないことが多い。
なので新しい文字列をチェックするたびに前と同じ開始状態、受理状態、規則集を読み込む必要がある。

DFAが理解しやすいのはなじみの機械と似ているから。ある意味当然。
少し考え方を変えて実験実施ということでやり方の1つとして仮定や制約を少しずつ取り除いていく。
方法は以下。
・全ての状態ですべての可能な入力文字に関心があるわけではないので関心のない文字の規則をなくしてなくした文字の場合は失敗状態にする。
・入力することで状態を変更していたが入力をなくしても状態を変更したらどうなるか

3番目の文字がbである限り文字aとbを受理する有限オートマトンがあったとして
最後から3番目の文字がbである文字列を受理する機械が必要な場合どうするか。
決定性制約を緩和して与えられた状態と入力に対して複数の規則を含む規則集を用意することで設計可能。
こういった状態機械のことを非決定性有限オートマトンと呼ぶ。（NFA）
NFAは入力シーケンスに対し複数の実行パスを持つことができる。

DFAの場合は盲目的に文字を読んで規則に従い最終的に受理状態になれば受理されるようになっていたが
NFAの場合は規則に従い受理状態になるなんらかのパスがある、起こらなくても受理状態で終わる可能性があれば受理される。

NFAの場合は何が起こるかではなく何が起こる可能性があるかという観点で語られる。
NFAをシミュレートするためには全ての可能な実行を調べる方法を見つける必要がある。
つまり何とかして全ての可能性を試しどうすれば最終的に受理状態に到達できるかを調べることで非決定性をシミュレートできる。
これは全ての可能性を再帰的に試していくことで実現可能
流れとしては以下
適用可能な規則が複数ある場合、
規則のどれかひとつにしたがって残りの入力を読む→受理状態にならなければ前の状態に戻って入力をその位置まで巻き戻し、
別の規則にしたがって再試行→規則の選択によって受理状態に導かれるか、全て失敗するまで繰り返す
もしくは適用可能な規則が複数あるたびに新しいスレッドを生成して全ての可能性を並行してシミュレートすることも可能。
両方とも実装可能だが複雑で非効率。
効率的な方法として取り得る現在の状態を全て記録することでシミュレート可能。

NFAクラスはDFAクラスとよく似ているが、違っているのは明確に1つの状態であるcurrent_stateの変わりに
取り得る状態の集合であるcurrent_statesを持っていること。

有限オートマトンを応用すると正規表現が可能になる。
任意の正規表現はそれと等価なNFAに変換することが出来る。その逆としてNFAのシミュレーションに受理されるかを
確かめることで正規表現とマッチングすることができる。

正規表現とは
・空の正規表現
・1つのリテラル文字を含む正規表現
これらのパターンを利用して正規表現を作るには3種類の組み合わせがある。
・2つのパターンを連結する→abとあればabだけにマッチする。
・2つのパターンのどちらかを選択する→｜で繋げる。a|bならaとbにマッチする。
・パターンを0回以上繰り返す→a*のようなやつ

NFAに変換する方法として、空と1文字は簡単
2つ以上の文字が対象の場合(and)、2つのNFAを並べて自由移動でつなぎ2番目のNFAの受理状態を全体の受理状態にする。
orの場合は入力を読む前に自由移動によってもとのNFAの開始状態のいずれかに移動できるのでどちらかを読むことで受理状態に移動できるようにする。

*を受理するためには以下2つの事柄を追加する必要がある。
・受理状態から開始状態への自由移動を追加する。→複数回マッチ用処理
・受理状態でもある開始状態を新しく追加してそこから元の開始状態への自由移動を追加する。→空文字列マッチ用処理
追加する構成要素は以下
・受理状態でもある新しい開始状態
・元のNFAのすべての受理状態
・元のNFAのすべての規則
・元のNFAの受理状態を元の開始状態に繋げるための追加の自由移動
・新しい開始状態を元の開始状態に繋げるための追加の自由移動

開き括弧と閉じ括弧がペアになっているものをバランスが取れている文字列とする場合、方法としては
現在のネストレベルを記録していく方法。開き括弧が出てくれば+1 閉じ括弧が出てくれば-1とすれば
最終的に0になっていればバランスが取れている、それ以外はバランスが取れていないものとなる。
NFAで正規表現と同じように実装した場合、
ネストレベル分状態を保持できるように状態の数を用意しなければならない。
そもそもNFAは有限個の状態を維持することが必須のため、任意の数を認識できるようなものを作成することは不可能である。

計算中にデータを保持できる記憶領域があれば有限状態機械を拡張することができる。
保持する記憶領域は外部記憶を利用する。
オートマトンにストレージを追加する簡単な方法はスタックへのアクセスを提供すること。
スタック＝後入れ先だしのデータ構造。
組み込みのスタックを持つ有限状態機械はプッシュダウン・オートマトンと呼ばれる。
その中でも機械の規則が決定的である場合、決定性プッシュダウン・オートマトンと呼ばれる。
これを利用した場合、括弧のバランスが取れている文字列を認識するものを作成すると以下のようになる。
・機械に2つの状態1と2を与え、状態1を受理状態にする。
・機械を空のスタックで状態1から開始する。
・状態1で開き括弧を読むとなんらかの文字をスタックにプッシュし状態2に移動する
・状態2で開き括弧を読むとなんらかの文字をスタックにプッシュする。
・状態2で閉じ括弧を読むとなんらかの文字をスタックからポップする。
・状態2でスタックが空だと状態1に戻る。

プッシュダウンオートマトンの規則は5つの部分に分割される。
・機械の現在の状態
・入力から読む必要のある文字
・機械の次の状態
・スタックからポップする必要のある文字
・スタックのトップにある文字をポップした後、スタックにプッシュする文字のシーケンス

プッシュダウンオートマトンにおける決定性は行き詰まり状態になったとする。

有限オートマトンの場合、規則に従う＝別の状態に変更であったが、プッシュダウンオートマトンの場合、
スタックの内容も変更する。

決定性制約のないプッシュダウンオートマトンを非決定性プッシュダウンオートマトンと呼ぶ。そのまんま。

NFAからDFAへの変換は可能だがDPDAからNPDAへの変換は不可能。スタックが原因。
そのためNPDAのほうがDPDAより能力が高いとなる。

NPDAで字句解析や構文解析が可能となる。

1つの組み込まれたタスクを実行すのは今までのものでよかったが実際にプログラムを実行できるような
コンピュータにしていくには何が必要か。
アランチューリングが設計した自動機械（automation machine）がそれにあたる。
スタックを使って任意の量のデータを格納することができるようになったが取り出しに課題がある。
そのためスタックを柔軟なストレージ置き換えることでもっと機械の能力を高めることができる。

チューリングの解決策は無限の長さの空白テープを機械に持たせてテープの任意の場所に
読み書きできるようにするもの。
このテープにアクセスできる有限状態機械のことをチューリングマシンと呼ぶ。
任意の場所に読み書きできるようにするには以下の選択肢がある。
・RAMのように各マスにユニークなアドレスを付与しテープをランダムアクセス可能にすること
→無限のテープにどうやってアドレスを振るかが問題
・テープヘッドを使う。テープヘッドだけを付与し1ステップごとにそこから左右どちらにでも動けるようにしておく
→テープヘッドを動かす必要があるが、それは単純に時間がかかるだけの話。今のHDDと一緒。

DTMはDFAやDPDAとほぼ一緒。characterを読まないのは読むのは機械ではなくテープだから。
DTMは内部にストレージがないため記憶することができない。なので一回読んだ文字を再度呼び出すためには
もう一回読む必要がある。
ルールブックを作り変えることでレジスタのようなものを機能として得ることができる。

複数のストレージを持たせることで能力が高まることもある。

Rubyでラムダ計算を実装する。
そのために制約を設ける。以下のことしかできない。
・変数の参照
・procの生成
・procの呼び出し
以下のようなコードになる。
->x { -> y {x.call(y)}}
そもそもprocとは。プログラムのあちこちに値を動かすための配管。呼び出すと何が起こるか
->x { x + 2 }.call(1)
この場合、引数として与えられた1がブロックの引数のxに流れ、その引数が使われている場所すべてから流れる。
なので1 + 2を評価することになる。
また
->x,y{x+y}.call(3,4)
という式は
->x->y{x+y}.call(3).call(4)
という形に書き直すことができる。今回は引数1つの計算で進める。

世の中の複雑さは複雑なシステムからもたらされる。
だからといって単純なシステムには単純なことしかできないかといえばそうではない。

ラムダ計算には自分自身をシミュレートする方法が少なくとも1つはある。
チューリングマシンをラムダ計算で実装しそのあとシミュレートした機会を使ってラムダ計算インタプリタを実行すればよい。

部分再帰関数は4つの基本構成要素を組み合わせて構成されたプログラム。
基本構成は以下
・zero
・increment
・recurse
・minimize

以下3つで組み立てられるプログラムは原始再帰関数と呼ばれる。
・zero
・increment
・recurse
原始再帰関数はすべて全域的である。つまりどんな入力であっても必ず停止して答えを返す。
本当に万能なシステムを手に入れるにはminimizeを追加する必要がある。

minimizeはブロックを引数にとり、それを1つの数の引数で繰り返し呼ぶ。

SKIコンビネータ計算とはラムダ計算とおなじように式の構文を操作する規則のシステム。
ラムダ計算よりは単純。

ギリシャ文字のイオタ（ι）はSKI計算に加えることの出来る追加のコンビネータ。
簡約規則はι[a]をa[S][K]に簡約する
イオタも万能。

タグシステムとは単純化したチューリングマシンのように動く計算モデル。
テープ上でヘッドを動かすわけではなく文字列の末尾への新しい文字の追加と先頭からの文字を削除することを繰り返す。
タグシステムは2つの部分から構成される。
・規則の集合。例えば文字aが文字列の先頭にあるときbcdを追記するといったようなもの。
・削除数

循環タグシステムとは追加の制約を課することでさらに単純にしたタグシステム。
・循環タグシステムは0と1しか扱わない
・規則は1から始まるときのみ適用
・循環タグシステムの削除数は常に1

1970年、コンウェイがライフゲームと呼ばれる万能システムを考案。
ライフシステムは正方形のセルからなる無限の2次元グリッド上で行われそれぞれ生か死のどちらかになる。
セルは8つの近傍に囲まれており、上には3つのせる、左右には2つのセル、下には3つのセルがある。
そのセルは生→死もしくは死→生に規則にしたがって変化する。
これは循環タグシステムに置き換えることが可能なので万能といえる。

万能システムはアルゴリズムを実行できると考えることが出来る。
アルゴリズムとは入力値を出力値に変えるプロセスを記述した命令のリストであり、以下の基準を満たしている。
・有限性
  →命令が有限個であること
・単純性
  →創意工夫することなく人が紙と鉛筆で実行できるくらい単純であること
・停止性
  →任意の入力について有限回のステップで終わらせること
・正確性
  →任意の入力について正しい答えを生成することができること。

問題となるのはどのアルゴリズムも機械で実行可能な命令に変換できるか。

プログラムを実行したとき、必ず停止することができるか＝停止性問題
→出来ない。
プログラムを実行したとき、特定の文字列を判断して出力するか自動判別することができるか
→出来ない
必ず停止するものが作れない以上、以下のことに注意してプログラムを作成すること
・決定不能な問題はタイムアウトを実装すること
・複数の小さな質問を実施することで大きな質問に対する答えの経験的証拠にする

プログラムを解析するのに実際に実行することなく解析できれば便利
→抽象解釈

抽象解釈とは直接取り組むには大きすぎたり、難しすぎるものにアプローチする手法。
→例えば行った事のない道を行くのに事前に地図で確認しておくといった内容。