第8章  ファジング

ファジングはソフトウェアに潜むバグを検出する方法として効果的。
ファジングとはアプリケーションがエラーを起こすことを狙って不適切な形の
あるいは不完全な形のデータを生成してアプリケーションに送り込むこと。
ファジングツールのことをファザーと呼ぶ。

ファザーには2種類ある。
・生成ファザー
  ターゲットに送り込むデータを新規に生成する
・変異ファザー
  既存のデータに変更を加えることでデータを生成する

バグクラスの中で多いものは以下
・バッファオーバーフロー
脆弱性の中では最も一般的なタイプ。
簡潔に言うと大量のデータをメモリ領域に格納しようとしてそれらデータの全てを
保持するだけの容量が当該メモリ領域になかった場合、バッファオーバーフローが発生する。
あふれ出たデータで他のメモリ領域を上書きすることでシステムへの侵入等が可能になる。
バッファオーバーフローは2つ
  スタックベース
    特徴はバッファオーバーフローによってスタック上のデータが上書きされる。
    上書きすることによって実行フローを制御できる。
  ヒープベース
    実行中プロセスのヒープセグメント内部で発生する。
    ヒープセグメントにはアプリケーションの実行時に動的にメモリがアロケートされる。
    ヒープはメタデータによって結び付けられる複数のチャンクから構成されている。
    そのデータを上書きすることで攻撃する。
    例外発生が遅れるので追跡は困難。

・整数オーバーフロー
コンパイラが整数に割り当てる領域のサイズとそれら整数に対する算術演算をプロセッサが処理する仕組みに関連している。
整数は4294967295までの値を保持できそのサイズは4バイト。その最大値を超える値を格納した場合整数オーバーフローが発生する。
32ビットの領域に格納するのは無理なため保存できるよう高位ビットを切り落とす。
それで問題になる例は以下
この例では整数オーバーフローが原因となってアロケートされるメモリ領域がずっと小さくなり
結果的にバッファオーバーフローが発生する可能性がある。
MOV EAX, [ESP + 0x8] -> スタック上の[ESP + 0x8]からパラメータを取り出しそれをEAXレジスタにロードする。
LEA EDI, [EAX + 0x24] -> EAXに0x24を加算しその結果をEDIレジスタに格納する。
PUSH EDI
CALL msvcrt.malloc この結果の値をメモリアロケーションルーチンmallocへの唯一のパラメータとして使っている。
この場合、上限値に近い非常に大きな値がEAXに保持されている状態なので
それに足すと切り落としが発生する。
実際の動きは以下の通り。
スタックのパラメータ＝0xFFFFFFF5
算術演算＝0xFFFFFFF5 + 0x24
演算結果＝0x100000019  ここで収まらない
切り落とし=0x00000019
この通り非常に小さい値になる。
これによってプログラムは異常な動きをする可能性がある。

・書式指定文字列攻撃
Cのprintf関数などの一定の文字列操作ルーチンで書式指定子として扱われる文字を利用した攻撃。
printfの第一パラメータは書式指定子を含む文字列。
これは書式処理される値を保持する残りのパラメータと結び付けられる。

書式処理を忘れると変数を書式指定文字を指定された場合、それをパラメータとみなし表示してしまう。
このときに利用できるのは%sと%n
%sは文字列の末尾を表すヌルバイトが見つかるまでメモリ中の文字列を取り込むべきことを表す。
大量のデータを読み込みたい場合に利用。
%nはメモリ中にデータを書き込むことが可能になる点でユニーク。
戻りアドレスや既存のルーチンへの関数ポインタを上書きできるので
攻撃者は任意のコードを実行できるようになる。

※またもpydbgなのであきらめる。

コードガバレッジとはターゲットアプリケーションのテスト時にどれだけのコードが実行されたかの尺度
コードガバレッジが向上すると検出されるバグの数も多くなる。