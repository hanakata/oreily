デバッガの基本原理

デバッガを使えばプロセスの実行時トレース「動的解析」が可能になり、
動的解析はエクスプロイトの開発、ファジングの支援、マルウェアの調査などを
行う上で欠かせないものなので、非常に重要。
仕組みを知っておくことも重要。
デバッガには以下の2種類が存在する
ホワイトボックスデバッガ
→通常のIDEとかに入っているやつ。コード開発時には意味があるが、コードを持っていなければ意味がない。
ブラックボックスデバッガ
→入手可能なものが逆アセンブルしたコードだけであると想定した場合のデバッガ。
  リバースエンジニアやバグハンターが良く使う。
ブラックボックスデバッガを利用する場合、ユーザモードとカーネルモードを区別することが重要。
ユーザモード
  →ring3と呼ばれるやつ。アプリケーションが動作するプロセッサモード
  権限は最小で作動する。
カーネルモード
  →ring0とよばれるやつ。権限が最高レベルになる。
  例えばWiresharkを使ってパケットスニッフィングを行う場合カーネルモードで動作する
  ドライバを利用する。

レジスタ＝CPUに備わっている少量の記憶装置でCPUがデータにアクセスするための最速の手段
x86命令セットではCPUは8つの汎用レジスタ、EAX、EDX、ECX、ESI、EDI、EBP、ESP、EBXを使用できる。
8つのレジスタはそれぞれ特定の用途向けに設計されており、CPUが命令を効率的に処理できるように
それぞれの機能を遂行する。
それぞれの機能は以下
EAX・・・アキュームレータとも呼ばれ計算処理の遂行と関数からの戻り値の格納に利用。
        加算、減算、比較といった基本的な演算の大多数はEAXレジスタを利用するために最適化されている。
        また乗算、除算などの専門性の高い演算はEAXレジスタのみで実行できる。
        戻り値は必ずEAXレジスタに格納されるので関数呼び出しの成否や返している値も分かる。
EDX・・・データレジスタ。EAXレジスタの拡張。乗算や除算といった複雑な計算処理向けに必要なデータを保持して補助的な役割を果たす。
        汎用的なデータ保持にも利用されるが基本的にはEAXレジスタで遂行される計算処理に併用される。
ECX・・・カウントレジスタ。ループ処理用に利用。
        ECXレジスタは上方向ではなく下方向にカウントする。
        例えば10回繰り返すプログラムの場合であれば最初が10、それからカウントされるごとに減っていく。
ESI・・・ソースインデクスとして入力データストリームの位置を保持
EDI・・・デスティネーションインデクスとしてデータ処理の結果を格納
ESIとEDIはループで利用。ESIは読み取り、EDIは書き込みと覚えれば良い。
ESP・・・スタックポインタ。スタックの先頭を指すため戻りアドレスを指すことになる
EBP・・・ベースポインタ。呼び出しスタックの最下部を指す。
ESPとEBPは両方ともスタック操作で呼ばれる。
コンパイラの最適化の結果、スタックフレームポインタとしてのEBPレジスタが除去される場合がある。
その場合は他の汎用レジスタと同様に使えるようEBPレジスタが解放される。
EBX・・・特定の用途のために設計されていないのでデータ記憶用に使う。

EIP・・・各時点で実行されている命令を指す。CPUがバイナリ実行コード中を移動するのに伴い
        その実行している場所を指すようにEIPレジスタを更新する。
デバッガはこれらのレジスタの内容の読み取りと変更を簡単に行える必要がある。

デバッガの開発にはスタックに関する知識が欠かせない。
スタックには開発の呼び出しに関する情報が保持されFILO方式の構造になっている。
関数を呼び出した場合、スタック中に引数がpush(格納)され関数の実行が終了したら
スタックから引数がpop(除去)される。
スタックフレームの最上部にはESPレジスタによって管理され最下部はEBPによって管理される。
例えば
int my_sock(color_one,color_two,color_three);
とあった場合。関数の呼び出しは
push color_three
push color_two
push color_three
call my_sock
となる。
この時点でのスタックフレームは以下の通り
戻りアドレス(ESP)
color_one
color_two
color_three
スタックフレームの基底(EBP)

スタックはデータ構造として単純ではあるが、
全ての関数呼び出しの基板をなしている。
関数my_sockから戻るいはこのスタックすべての値がpopされさらに戻りアドレスにジャンプすることで
この関数を呼び出した親関数に戻る。
後はローカル変数も考慮が必要。ローカル変数＝実行されている関数でのみ有効なメモリ領域。
ローカル変数は現在のスタックフレームの中にアロケートされて利用可能になる。
そのアロケーションが行われた後のスタックフレームは以下
ローカル変数(ESP)
戻りアドレス
color_one
color_two
color_three
スタックフレームの基底(EBP)
スタックポインタが更新されてスタックの先頭を指している。
クラッシュ時におけるスタックの状態を補足する、スタックベースのバッファオーバーフローを検出するには
スタックフレームデバッガで補足することが重要な意味を持つ

デバッガはデバッグイベントを待つ永久ループとして作動する。
デバッグイベントが発生したらそれに対応するイベントハンドラが呼び出される。
イベントハンドラが呼び出されるとデバッガは一旦自身の実行を停止し次の指示を待つ。
補足すべきデバッグイベントは以下
・ブレークポイント到達
・メモリ違反
・デバッグ対象プログラムが生成する例外

デバッグ対象のプロセスを一時的に停止させるにはブレークポイントを設定する。
プロセスを一時停止することで変数、スタック上の引数、メモリ位置などを調べることが出来る。
ブレークポイントは3つ存在する
・ソフトウェアブレークポイント
  アプリケーションプログラムをデバッグするときに利用する最も一般的なタイプのブレークポイント。
  プログラムの実行中にCPUを一時停止する。
  ソフトウェアブレークポイントでは1バイトの命令によってプロセスの実行が停止され
  デバッガのブレークポイント例外ハンドラに制御が渡される。
  例えば
  MOV EAX, EBX
  この命令はEBXレジスタに格納されている値をEAXレジスタに移すという動作。
  オペコードに変換されていないのでこのままではCPUはこの命令を解釈できない。
  なのでオペコードに変換すると
  8BC3
  となり、これで解釈が出来る。
  ソフトウェアブレークポイントに関してはオペコードの理解が必要。
  例えば上の命令が0x44332211というアドレスにあった場合、
  0x44332211:   8BC3    MOV EAX,EBX
  と表現される。
  このアドレスにソフトウェアブレークポイントを設定してCPUを停止されるには
  8BC3という2バイトのオペコード中の1バイトを入れ替える必要がある。
  その1バイトは割り込み3(INT 3)の命令をあらわすものでそれによってCPUが停止される。
  INT 3命令を1バイトのオペコードに変換すると0xCCになる。
  なのでブレークポイントを指定すると以下のようになる。
  0x44332211:   CCC3    MOV EAX,EBX
  8BがCCに置き換えられているのでここで処理を停止しINIT 3イベントを引き起こす。

  デバッガはある特定のアドレスにブレークポイントを設定するように指示されると
  そのアドレスにある最初のオペコードを読み取って保存しそのアドレスにCCを書き込む。
  CPUがそのCCを見つけてブレークポイントイベントを起こすとデバッガが捕捉する。
  デバッガはブレークポイントが設定されたアドレスを命令ポインタがさしているかを確認する。
  そのアドレスがデバッガ内部のブレークポイントエントリに見つけれられれば保存していたバイトを
  該当アドレスに書き戻しプロセス再開時にオペコードが適切に実行される。

  ソフトウェアブレークポイントには2種類ある。
  1回限定のブレークポイント
    1回でも到達すれば内部のブレークポイントリストから削除される。
  持続性のブレークポイント
    ずっとブレークポイントリストに維持される。
  注意点としてメモリ中の実行コードを1バイトでも変更するとCRCチェックサムが変わるので
  CRCチェックが失敗する。
  これが重要なのは多くのマルウェアはそのメモリ内の実行コードについて
  CRCチェックサムの変更をチェックし変更が検出されたら自身をkillする。
  そうされるとマルウェアの動的解析に制約が課せられるため、そういった場合にはハードウェアブレークポイントが利用できる。

・ハードウェアブレークポイント
  必要なブレークポイントが少なくデバッグ対象のソフトウェアに変更を加えることが出来ないときに有効。
  このタイプのブレークポイントはデバッグレジスタと呼ばれる特殊なレジスタを通してCPUレベルで設定される。
  一般にCPUはデバッグレジスタをDR0からDR7までの8つを備えており、これらのデバッグレジスタを使えば
  ハードウェアブレークポイントを設定管理することが出来る。

  DR0からDR3まではブレークポイントのアドレスを保持する。
  なので一度に設定できるハードウェアブレークポイントは4つまで。
  DR4とDR5は予約済み。DR6は状態レジスタとして使われブレークポイントの到達時に引き起こされた
  デバッグイベントのタイプを決定する。
  DR7は基本的にハードウェアブレークポイントのon/offスイッチだが各種条件も保持。
  そのため次の条件に対しブレークポイントを設定できる
  ・特定のアドレスにある命令の実行時にブレークする
  ・特定のアドレスに対するデータの書き込み時にブレークする
  ・特定のアドレスに対する読み取り、書き込み時にブレークするが実行時はブレークしない。

  INT3を使わずINT1を利用する。INT 1はハードウェアブレークポイントと単一ステップイベントを表す。
  単一ステップはプログラム命令を1つずつ先に進める事を意味するためデータの変化を監視しながらコードの
  クリティカルセクションを詳細に調べることが出来る。

  ハードウェアブレークポイントはソフトウェアブレークポイントと似たような動きをするが
  メカニズムはより低いレベルで作用。
  CPUは各命令を実行する前にそのアドレスについてハードウェアブレークポイントが有効になっていないか
  チェックを行う。またハードウェアブレークポイントが設定されているメモリ領域に対するアクセスが
  発生していないかもチェックしている。
  該当するアドレスがDR0からDR3までのデバッグレジスタに格納されており、読み取り、書き込み、実行の
  ブレークポイント条件に合致する場合INT 1が引き起こされる。
  制限は4つのみ指定できるということと、4バイトまでのデータに対してのみしか設定できない。
  この制約を回避するにはメモリブレークポイントをデバッガで利用する。

・メモリブレークポイント
  メモリブレークポイントは実際にはブレークポイントではない。
  デバッガはメモリブレークポイントを設定する際にメモリのページに対するパーミッションを変更する。
  メモリのページはオペレーティングシステムが扱うことの出来る最小単位のメモリ領域。
  メモリページがアロケートされる際にそのページにパーミッションが設定され
  その設定によりアクセスできるかが決まる。
  パーミッション例は以下
  ページ実行・・・実行は可能。読み取り書き込みが発生すると例外。
  ページ読み取り・・・読み取りは可能。書き込み、実行すると例外。
  ページ書き込み・・・書き込み可能
  保護ページ・・・アクセスが行われると例外が1回発生する。
  重要なのは保護ページ。
  例えばサーバアプリケーションのリバースエンジニアリングを実行する場合、
  受信したパケットのペイロードが格納されるメモリ領域に対してメモリブレークポイントを設定することで
  受信したパケットの内容をそのアプリケーションがどのタイミングでどう使うかが見極めることが出来る。
  